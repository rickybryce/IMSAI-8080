; PROGRAM TO DISPLAY OCTAL, HEX AND BINARY FOR Z80 MACHINES
; RUNNING UNDER CP/M

; SENSOR SWITCHES DETERMINE THE HIGH BYTE OF
; THE DELAY LOOP
; 7 AND 6 ONLY WILL EXIT TO CP/M
; 

; THIS PROJECT SHOULD ASSEMBLE FINE USING AZ80
; OR Z80ASM BY SLR SYSTEMS
;
; IF YOU USE Z80ASM BY SLR SYSTEMS (1983):
; A .Z80 EXTENSION IS ASSUMED, SO BE SURE YOUR EXTENSION
; IS .Z80.  SOURCE, DESTINATION, AND LISTING ARE ALL ON
; DRIVE B (BBB).  /F FOR A FULL LISTING.
; Z80ASM FILENAME.BBB/F
; -- RICKY BRYCE



    ORG 0100H       ; CP/M PROGRAMS RUN AT 0100H
    
; DEFINE PRESETS FOR DELAY LOOP


; ** BEGIN HEAD **

SYSTEM:     EQU 05H ; BDOS SYSTEM CALL FOR CP/M
CONSOLE:    EQU 09H ; FUNCTION CODE FOR CONSOLE WRITE
DELAYLOW:   EQU 01H ; DELAY LOW BYTE START 51H
DELAYHIGH:  EQU 40H ; DELAY HIGH BYTE START 01H
SWITCHES:   EQU 0FFH ; PORT FOR SENSOR SWITCHES
LIGHTS:     EQU 0FFH ; PORT FOR LIGHTS (LEDS)
TERMINATE:  EQU 24H  ; DOLLAR SIGN
LFEED:      EQU 0AH  ; LINE FEED
CRETURN:    EQU 0DH  ; CARRIAGE RETURN
INVERTFLAG: EQU 01H  ; INVERT OUTPUTS
ENABLEOUT:  EQU 01H  ; ENABLE OUTPUTS
LESSDELAY:  EQU 01H  ; LOWER DELAY (FASTER LOOP=1)

; ** END HEAD **


; ** BEGIN INITIALIZE **    
SETUP:
    XOR A
    LD IX,DELAYTIME ; LOAD IX WITH DELAY TIME MEMORY LOCATION
    LD (IX+0),DELAYLOW  ; HIGH BYTE DELAY LOOP
    LD (IX+1),DELAYHIGH ; LOW BYTE DELAY LOOP
    LD A,CRETURN    ; LOAD A WITH CARRIAGE RETURN VALUE
    LD (CRLF),A     ; WRITE THIS TO CRLF
    LD A,LFEED      ; LOAD A WITH LINEFEED VALUE
    LD (CRLF+1),A   ; STORE THE NEXT CHARACTER TO CRLF
    LD A,TERMINATE  ; LOAD A WITH TERMINATION CHARACTER
    LD (CRLF+2),A   ; STORE THIS VALUE TO THE CRLF STRING

INIT: ; INITIALIZE REGISTERS AND MEMORY

    XOR A           ; ZERO ACCUMULATOR
    LD (OCTAL),A     ; CLEAR LOW OCTAL BYTE
    LD (OCTAL+1),A     ; CLEAR HIGH OCTAL BYTE
    LD (COUNTER),A  ; START COUNTER AT ZERO
    LD (DECIMAL),A  ; START COUNTER AT ZERO
    LD (DECIMAL+1),A  ; START COUNTER AT ZERO

; ** BEGIN MAIN ROUTINE **
BEGIN:
BUILDDEC:               ; BUILD DECIMAL DATA
    ; FIRST DIGIT
    LD A,(DECIMAL)      ; LOAD A WITH OCTAL VALUE
    AND 0FH             ; MASK OUT THE UPPER BITS
    ADD A,30H           ; ADD 30 FOR ASCII ADJUSTMENT
    LD (MSGDEC+2),A     ; STORE THE FIRST CHARACTER

    ; SECOND DIGIT
    LD A, (DECIMAL)	; LOAD A WITH DECIMAL VALUE
    SRA A ; SHIFT RIGHT 4 TIMES
    SRA A
    SRA A
    SRA A
    AND 0FH             ; DROP UPPER 4 BITS
    ADD A,30H           ; ADJUST FOR ASCII
    LD (MSGDEC+1),A     ; SAVE TO NEXT BYTE

    ; THIRD DIGIT
    LD A, (DECIMAL+1)     ; GET THE HIGH BYTE
    AND 0FH             ; BE SURE TO MASK ANY UPPER BITS
    ADD A,30H             ; ADJUST FOR ASCII
    LD (MSGDEC),A     ; SAVE TO THE NEXT BYTE.

    ; ADD TERMINATION CHAR
    LD A,TERMINATE      ; LOAD TERMINATION TO A
    LD (MSGDEC+3),A     ; SAVE TO NEXT BYTE -- MESSAGE BUILT

    ; INCREMENT DECIMAL
DEC1CHAR:   ; (USING LOW NYBBLE OF L)
    ; INSTEAD OF USING DAA, I'LL JUST SPELL OUT THE CONVERSION TO DEC
    LD HL,(DECIMAL)     ; LOAD DECIMAL MEMORY TO HL
    INC HL		; INCREMENT HL
    LD (DECIMAL),HL	; STORE THE NEW VALUE BACK TO HL
    LD A,L		; LOAD LOW BYTE TO A
    AND 0FH		; FILTER UPPER BITS
    CP 0AH		; SEE IF WE'VE REACHED A YET
    JR NZ, CONTDEC	; IF NOT, THEN CONTINUE
    LD HL,(DECIMAL)	; IF SO, RELOAD HL WITH DECIMAL
    LD A,L		; GET THE LOWER BYTE
    ADD A,06H		; ADD 6 TO AVOID A-F
    LD L,A		; STORE NEW VALUE BACK TO L
    LD (DECIMAL), HL	; STORE THE ADJUST VALUE TO MEMORY

DEC2CHAR:   ; (USING HIGH NYBBLE OF L)
    LD HL,(DECIMAL)     ; LOAD THE VALUE OF DECIMAL TO HL
    LD A,L              ; LOAD L TO A
    AND 0F0H            ; MASK OUT THE LOWER NYBBLE
    CP 0A0H             ; SEE IF WE'VE REACHED A0H
    JR NZ,CONTDEC       ; IF NOT THEN CONTINUE
    LD L,00H            ; BUT IF SO, LOAD L WITH 00H
    INC H               ; THEN INCREMENT H
    LD (DECIMAL),HL     ; STORE THE VALUE OF HL BACK TO DECIMAL

DEC3CHAR: ; (USING LOW NYBBLE OF H)
    LD HL,(DECIMAL)     ; LOAD HL WITH DECIMAL
    LD A,H              ; TRANSFER H TO A
    CP 03H              ; IF IT'S 3, THEN IT'S TOO HIGH
    JR NZ,CONTDEC       ; IF NOT THEN WE ARE OK TO CONTINUE
    LD A,00H            ; IF VALUE WAS A, LOAD 00H TO A
    LD H,A              ; THEN SET H TO ZERO

CONTDEC:    ; NOTHING ELSE TO DO WITH DECIMAL


CONTHEX:    ; BUILD HEX DATA FROM COUNTER
    ; FIRST DIGIT
    LD A,(COUNTER)      ; LOAD A WITH OCTAL VALUE
    AND 0FH             ; MASK OUT THE UPPER BITS
    CP 0AH		; SEE IF WE'VE REACHED A YET
    JR C, CONTHEX2	; IF SO, THEN ONLY ADD 30H
    ADD A,07H           ; GET US UP TO ASCII LETTERS

CONTHEX2:
    ADD A,30H            ; ADD 30 FOR ASCII ADJUSTMENT
    LD (MSGHEX+1),A      ; STORE THE FIRST CHARACTER

    ; SECOND DIGIT
    LD A, (COUNTER)	; LOAD A WITH COUNTER
    SRA A 		; SHIFT RIGHT 4 TIMES
    SRA A
    SRA A
    SRA A
    AND 0FH             ; DROP UPPER 4 BITS
    CP 0AH		; SEE IF WE'VE REACHED A YET
    JR C, CONTHEX3	; IF NOT, THEN ONLY ADD 30H
    ADD A,07H           ; GET US UP TO ASCII LETTERS

CONTHEX3:
    ADD A,30H           ; ADJUST FOR ASCII
    LD (MSGHEX),A     	; SAVE TO NEXT BYTE

    ; ADD TERMINATION CHARACTER
    LD A,TERMINATE      ; LOAD TERMINATION CHAR TO A
    LD (MSGHEX+2),A     ; SAVE TO NEXT BYTE -- MESSAGE BUILT

BUILDOCT:               ; BUILD OCTAL DATA
; FIRST DIGIT
    LD A,(OCTAL)        ; LOAD A WITH OCTAL VALUE
    AND 0FH             ; MASK OUT THE UPPER BITS
    ADD A,30H           ; ADD 30 FOR ASCII ADJUSTMENT
    LD (MSGOCT+2),A     ; STORE THE FIRST CHARACTER

    ; SECOND DIGIT
    LD A, (OCTAL)
    SRA A  ; SHIFT RIGHT 4 TIMES
    SRA A
    SRA A
    SRA A
    AND 0FH		; DROP UPPER 4 BITS
    ADD A,30H           ; ADJUST FOR ASCII
    LD (MSGOCT+1),A     ; SAVE TO NEXT BYTE

    ; THIRD DIGIT
    LD A, (OCTAL+1)     ; GET THE HIGH BYTE
    AND 0FH             ; BE SURE TO MASK ANY UPPER BITS
    ADD A,30H           ; ADJUST FOR ASCII
    LD (MSGOCT),A     	; SAVE TO THE NEXT BYTE.

    ; ADD TERMINATION CHARACTER
    LD A,TERMINATE      ; LOAD TERMINATION CHARACTER TO A
    LD (MSGOCT+3),A     ; SAVE TO NEXT BYTE -- MESSAGE BUILT


    ; INCREMENT OCTAL
OCT1CHAR:               ; IF THE FIRST CHARACTER IS 8, WE NEED TO ADD 8
    LD HL,(OCTAL)       ; LOAD HL WITH THE LAST OCTAL VALUE
    INC HL              ; INCREMENT THIS VALUE
    LD (OCTAL),HL       ; THEN STORE HL BACK TO OCTAL MEMORY LOCATION
    LD A,L              ; LOAD THE LOW BYTE TO A
    AND 0FH             ; MASK OUT THE UPPER NYBBLE
    CP 08H              ; COMPARE TO 8
    JR NZ,CONTOCT       ; IF NOT 8, THEN WE ARE OK... CONTINUE
    LD HL,(OCTAL)       ; IF 8, THEN RELOAD OCTAL MEMORY LOCATION TO HL
    LD A,L              ; TRANSFER L TO A
    ADD A,08H           ; ADD 8H
    LD L,A              ; THEN STORE BACK TO L
    LD (OCTAL),HL       ; NOW STORE HL BACK TO THE OCTAL MEMORY LOCATION

OCT2CHAR:               ; NEXT, DEAL WITH THE UPPER NYBBLE
    LD HL,(OCTAL)       ; LOAD THE VALUE OF OCTAL TO HL
    LD A,L              ; LOAD L TO A
    AND 0F0H            ; MASK OUT THE LOWER NYBBLE
    CP 80H              ; SEE IF WE'VE REACHED 80H
    JR NZ,CONTOCT       ; IF NOT THEN CONTINUE
    LD L,00H            ; BUT IF SO, LOAD L WITH 00H
    INC H               ; THEN INCREMENT H
    LD (OCTAL),HL       ; STORE THE VALUE OF HL BACK TO OCTAL


CONTOCT:

CONTBIN:    ; JUST SEND THE VALUE TO THE OUTPUT LEDS
    LD A,ENABLEOUT	; SEE IF OUTPUTS ARE ENABLED
    JR Z,BUILDMESSAGE   ; IF NOT, SKIP OUTPUT LEDS 
    LD A,INVERTFLAG	; SEE IF WE NEED TO INVERT
    OR A		; CHECK A FOR ZERO
    JR NZ,INVERT	; IF NOT ZERO, THEN INVERT
NOINVERT:
    LD A,(COUNTER)	; LOAD A WITH COUNTER
    OUT (LIGHTS),A	; UPDATE LEDS
    JR BUILDMESSAGE     ; SKIP INVERT
INVERT:
    LD A,(COUNTER)	; LOAD COUNTER TO A
    XOR 0FFH		; INVERT IT
    OUT (LIGHTS),A	; STORE TO LEDS

BUILDMESSAGE:
	; OK, NOW THE FUN PART.  BULD A MESSAGE STRING
	; FROM THE COUNTER FOR BINARY
    LD B,08H		; WE'LL BE SHIFTING 8 TIMES (7-0)
    LD HL,MSGBIN  	; LOAD HL WITH OUR STARTING POINT
    LD A,(COUNTER)
    LD D,A		; LOAD D WITH CURRENT COUNTS
    
BINLOOP:
    SLA D		; SHIFT D LEFT
    JR C,BINHIGH        ; IF WE HAVE A CARRY, BIT WAS HIGH
BINLOW:    ; OTHERWISE, BIT WAS LOW
    LD A,30H		; ASCII ZERO
    LD (HL),A		; SAVE TO MEMORY
    JR BINJUMP
BINHIGH:
    LD A,31H		; ASCII ONE
    LD (HL),A		; SAVE TO MEMORY
BINJUMP:
    INC HL		; INCREMENT HL
    DJNZ BINLOOP	; DECREMENT B, AND JUMP IF NOT ZERO

    LD A,TERMINATE      ; LOAD TERMINATE CHARACTER
    LD (HL),A		; STORE TERMINATION TO NEXT MEMORY LOCATION


    ; DECIMAL
    LD      DE, DECSPELL    ; LOAD DE WITH DECIMAL TEXT
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING
    LD      DE, MSGDEC      ; LOAD DE WITH DEC STRING
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING
 
   ; HEX
    LD      DE, HEXSPELL    ; LOAD DE WITH HEX TEXT
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING
    LD      DE, MSGHEX      ; LOAD DE WITH HEX STRING
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING

    ; OCTAL
    LD      DE, OCTSPELL    ; LOAD DE WITH OCT TEXT
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING
    LD      DE, MSGOCT      ; LOAD DE WITH OCTAL STRING
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING

    ; BINARY
    LD	DE, BINSPELL	; LOAD DE WITH BIN TEXT
    LD C,CONSOLE	; FUNCTION CODE FOR CONSOLE WRITE
    CALL SYSTEM		; BDOS SYSTEM CALL
    LD DE, MSGBIN	; GET THE BINARY MESSAGE
    LD C,CONSOLE	; FUNCTION CODE FOR CONSOLE WRITE
    CALL SYSTEM		; BDOS SYSTEM CALL


    ; CRLF
    LD      DE, CRLF        ; LOAD DE WITH CRLF TEXT
    LD      C,CONSOLE       ; FUNCTION CODE TO FOR CONSOLE WRITE
    CALL    SYSTEM          ; CALL BDOS TO PRINT STRING

    ; UPDATE COUNTER
    CALL DELAY          ; START BY RUNNING A DELAY LOOP
    LD A,(COUNTER)      ; LOAD A WITH THE COUNTER TO DISPLAY
    INC A               ; INCREMENT A
    LD (COUNTER),A      ; THEN STORE A TO THE COUNTER MEMORY LOCATION
    OR A
    JP Z, INIT          ; RE-INITIALIZE

    JP BEGIN            ; START OVER


    
; ** END MAIN ROUTINE **


; ** BEGIN DELAY ROUTINE **
DELAY:
    IN A,(SWITCHES)       ; LOAD 8 WITH VALUE OF SWITCHES
    OR A		  ; CHECK FOR ZERO
    JR Z,NOSWITCH         ; ACCOUNT FOR BUTTONS
    CP A,0C0H             ; SEE IF SWITCH 7 AND 6 ARE ON
    JP Z, 0000H           ; IF SO, EXIT TO CPM
    LD (DELAYTIME+1),A	  ; STORE THIS TO HIGH BYTE OF DELAY
NOSWITCH:                 ; THIS WILL SLOW THE LOOP
    LD BC,(DELAYTIME)     ; LOAD BC WITH DELAYTIME

DELAY1:
    LD A,LESSDELAY	; SEE IF WE'RE CONFIGURED FOR LESS DELAY
    JP NZ,SKIPDLY	; IF SO, THEN SKIP THE INNER DELAY LOOP
    PUSH BC		; IF NOT, THEN BACKUP BC
    LD B,40H		; SET DELAY TO 40H LOOPS
ADDDLY:			; ADDITIONAL DELAY LABEL
    DJNZ ADDDLY		; LOOP UNTIL B=ZERO
    POP BC		; RESTORE BC
SKIPDLY:
    DEC BC              ; DECREMENT BC
    LD A,C              ; LOAD A FROM C
    OR B                ; SEE IF WE'VE REACHED ZERO YET
    JP NZ,DELAY1        ; IF NOT, THEN CONTINUE LOOP


    RET                 ; RETURN TO MAIN

; ** END DELAY ROUTINE **



; ** BEGIN FOOTER (DEFINE BYTES (DB)) **
    ;ORG 0300H		; AVOID CROSSING PAGE BOUNDARY
    
; ** BEGIN DATA TABLES (ARRAYS) **
DELAYTIME: 		; FOR DELAY LOOPS
    DB 00H,00H 	; THESE WILL BE OVERWRITTEN WITH
		;CONSTANTS DEFINED IN HEADER
				
COUNTER:        ; VALUE TO BE DISPLAYED ON LEDS AND RIGHTMOST 2 DIGITS
    DB 00H

OCTAL:          ; VALUE TO BE DISPLAYED ON LEFTMOST 4 DIGITS
    DB 00H,00H
DECIMAL:
    DB 00H,00H,00H
HEXADECIMAL:
    DB 00H, 00H
OCTSPELL:
    DB " OCT: $"
HEXSPELL:
    DB " HEX: $"
BINSPELL:
    DB " BIN: $"
DECSPELL:
    DB " DEC: $"
MSGBIN:
    DB 00H,00H,00H,00H,00H,00H,00H,00H,24H
MSGDEC:
    DB 00H,00H,00H,24H
MSGHEX:
    DB 00H,00H,24H
MSGOCT:
    DB 00H,00H,00H,24H
CRLF:
    DB 0AH,0DH,24H
				
				
				
; ** END DATA TABLES (ARRAYS) **  

; ** END FOOTER (DEFINE BYTES (DB)) **

    END

                                      